### 性能优化
从整个B/S链路中，前端能实现的优化主要分为两方面。一个是针对网络请求方面、二是接收到数据时的处理。

无网络传输界面交互时，有些编码写法也会影响浏览器执行效率。

##### 更快的网络通信
* CDN(content delivery network)
  * 全局负载均衡（物理位置方面：哪个更近请求哪个、请求量方面：哪个更不忙请求哪个）
  * 缓存机制（命中率、回源率：命中率越高越好，回源率越低越好）
* 请求次数
  * 合并请求（建立连接需要TCP协议三次握手、http头部信息数据量大）
    * 雪碧图、合并js文件等
  * 域名分片（浏览器请求并发量为6-8个，谷歌浏览器为6个，采用域名分片请求量多的页面可以更快的发送请求）
    * 多域名（二级域名、子域名）
* http1 压缩
  * head字段Accept-Encoding: gzip
  * 代码文件压缩
  * http1头部信息压缩、减少不必要的头、减少不必要的cookie
  * 静态资源压缩
    * 图片文件、字体图标等
    * 图片->更小的jpg或webp
* 浏览器缓存
  * 强缓存,Expires(http 1.0 绝对时间),Cache-Control(http 1.1 max-age 秒为单位)
    * 只有到设置的过期时间了浏览器才会发送请求，否则返回浏览器缓存中的文件
    * 如果两个都设置了，Cache-Control会覆盖Expires
  * 协商缓存（会发送请求）
    * Etag(server->brower) -> If-None-Match(brower->server)：服务器判断文件是否改变，如果没有改变返回304走缓存，如果没有改变返回新的Etag和文件
    * Last-Modified(server->brower) -> If-Modified-since(brower->server)：服务器判断文件是否改变，如果没有改变返回304走缓存，如果没有改变返回新的Last-Modified和文件
* 使用http2.0
  * 头部压缩算法（得益于该算法，合并请求和域名分片的优化反而影响效率了）
  * 二进制传输
  * 链路复用

##### 更高效的数据处理
* 伪元素不会被DOM遍历
* 不要在HTML中插入js代码，这样会导致浏览器在解析过程中调用js引擎，影响效率
* 能用css解决的不要用js实现。css引擎更高效
* 减少作用域查找和闭包、多用块级作用域

##### 其他
* react(next.js)、Vue(nuxt.js)应用的服务端渲染（解决白屏或前端响应渲染慢的问题）

2021.06.30