### 手撕钉钉前端考试

1. 浏览器存储设备
随机存储器RAM（SRAM、DRAM）
只读存储器ROM（MROM、PROM、EPROM、EEPROM）
2. 一般代码存储在计算机的哪个设备中，代码在CPU中是怎么运行的
答： 1)易失性执行之前，我们的代码主要存储在内存中。 ②CPU读取内存中的数据并放在寄存器内，将寄存器中的数据写入内存并进行有序的四则运算、相关指令，在此过程中，寄存器主要用于存放计算数据，运算器负责操作寄存器中的数据。
3. 什么是指令和指令集？
答： 指令一般是指机器指令，是计算机可完成一个独立计算逻辑所要执行的的命令；一台常规的计算机的所有指令的集合，就是该计算机的指令集。
4. JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？
答： ①JS代码->解析成 AST (期间伴随词法分析、语法分析)->生成字节码（V8）->生成机器码（编译器）
实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。
5. 简单描述一下 Babel 的编译过程？
答： 首先，Babel的作用是 从一种源码到另一种源码，充当转换编译器的作用，可以简述为 解析（解析JS代码）->转换（解析和修改AST）->重建（将修改后的AST转换成另一种JS代码）
6. JavaScript 中的数组和函数在内存中是如何存储的？
答：
①数组，如果数组中的元素是同一类型的，会分配连续的内存，否则将分配不连续的内存，并以类似hash表的方式存储。ArrayBuffer可以创建一块连续的内存
②函数，函数属于引用数据类型，存储在堆中，在栈内存中只是存了一个地址来表示对堆内存中的引用。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。
7. 浏览器和 Node.js 中的事件循环机制有什么区别？
答：
①浏览器中的事件循环：
macrotasks(宏任务):
script(整体代码)
setTimeout
setInterval
setImmediate
I/O
UI rendering
event listner
microtasks(微任务):
process.nextTick
Promises
Object.observe
MutationObserver
在浏览器里，每当一个被监听的事件发生时，事件监听器绑定的相关任务就会被添加进回调队列。通过事件产生的任务是异步任务，常见的事件任务包括：
用户交互事件产生的事件任务，比如输入操作；
计时器产生的事件任务，比如setTimeout；
异步请求产生的事件任务，比如 HTTP 请求。
主线程运行的时候，会产生堆（heap）和栈（stack），其中堆为内存、栈为函数调用栈。我们能看到，Event Loop 负责执行代码、收集和处理事件以及执行队列中的子任务，具体包括以下过程。
JavaScript 有一个主线程和调用栈，所有的任务最终都会被放到调用栈等待主线程执行。
同步任务会被放在调用栈中，按照顺序等待主线程依次执行。
主线程之外存在一个回调队列，回调队列中的异步任务最终会在主线程中以调用栈的方式运行。
同步任务都在主线程上执行，栈中代码在执行的时候会调用浏览器的 API，此时会产生一些异步任务。
异步任务会在有了结果（比如被监听的事件发生时）后，将异步任务以及关联的回调函数放入回调队列中。
调用栈中任务执行完毕后，此时主线程处于空闲状态，会从回调队列中获取任务进行处理。
上述过程会不断重复，这就是 JavaScript 的运行机制，称为事件循环机制（Event Loop）。
②NodeJs中的事件循环：
timersj阶段：这个阶段执行timer（setTimeout、setInterval）的回调
I/O callbacks：执行一些系统调用错误，比如网络通信的错误回调
idle,prepare：仅node内部使用
poll：获取新的I/O事件, 适当的条件下node将阻塞在这里
check：执行 setImmediate() 的回调
close callbacks：执行 socket 的 close 事件回调
③区别：
浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。如果是node11版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致。

8. ES6 Modules 相对于 CommonJS 的优势是什么？
答：
CommonJS和ES6 Module都可以对引入的对象进行赋值，即对对象内部属性的值进行改变；
CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。即ES6 Module只存只读，不能改变其值，具体点就是指针指向不能变；
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。
import 的接口是 read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对 commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会编译报错。
优势：
CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 Modules不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

作者：程序员思语
链接：https://juejin.cn/post/6987070062490288165
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


[原文链接](https://juejin.cn/post/6987070062490288165)